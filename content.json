{"meta":{"title":"gsfeng|博客","subtitle":"艰苦奋斗 常怀感恩之心","description":"致敬一起踩过的坑……","author":"gsfeng","url":"http://yoursite.com"},"pages":[{"title":"All categories","date":"2014-12-22T04:39:04.000Z","updated":"2018-08-02T06:36:15.397Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"All tags","date":"2018-08-02T06:22:22.000Z","updated":"2018-08-02T06:25:05.860Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Java集合框架源码解析（2）-JUC集合","slug":"20170830-Java集合-JUC集合","date":"2017-08-30T09:16:10.000Z","updated":"2018-08-02T03:57:20.087Z","comments":true,"path":"2017/08/30/20170830-Java集合-JUC集合/","link":"","permalink":"http://yoursite.com/2017/08/30/20170830-Java集合-JUC集合/","excerpt":"Java JUC介绍Java JUC","text":"Java JUC介绍Java JUC Java 集合系列——博文Java多线程系列–“JUC集合”01之 框架Java多线程系列–“JUC集合”02之 CopyOnWriteArrayListJava多线程系列–“JUC集合”03之 CopyOnWriteArraySetJava多线程系列–“JUC集合”04之 ConcurrentHashMapJava多线程系列–“JUC集合”05之 ConcurrentSkipListMapJava多线程系列–“JUC集合”06之 ConcurrentSkipListSetJava多线程系列–“JUC集合”07之 ArrayBlockingQueueJava多线程系列–“JUC集合”08之 LinkedBlockingQueueJava多线程系列–“JUC集合”09之 LinkedBlockingDequeJava多线程系列–“JUC集合”10之 ConcurrentLinkedQueue","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"多线程","slug":"多线程","permalink":"http://yoursite.com/tags/多线程/"},{"name":"JUC","slug":"JUC","permalink":"http://yoursite.com/tags/JUC/"},{"name":"集合","slug":"集合","permalink":"http://yoursite.com/tags/集合/"}]},{"title":"Java集合框架源码解析（1）","slug":"20170830-Java集合框架源码解析","date":"2017-08-30T08:16:13.000Z","updated":"2018-08-02T03:50:05.771Z","comments":true,"path":"2017/08/30/20170830-Java集合框架源码解析/","link":"","permalink":"http://yoursite.com/2017/08/30/20170830-Java集合框架源码解析/","excerpt":"最近几天看Java集合框架相关的博文，找到了一些很不错的文章。现整理分享出来。 常见的集合框架图网上流传最多的图，不多解释。","text":"最近几天看Java集合框架相关的博文，找到了一些很不错的文章。现整理分享出来。 常见的集合框架图网上流传最多的图，不多解释。 Java集合框架全图网上有大牛把Java集合整理在了一张图上。如下：在这里，集合类分为了Map和Collection两个大的类别:处于图片左上角的那一块灰色里面的四个类（Dictionary、HashTable、Vector、Stack）都是线程安全的，可是它们都是JDK的老的遗留类。如今基本都不怎么使用了，都有了相应的取代类。 当中Map是用来取代图片中左上角的那个Dictionary抽象类。官方推荐使用Map接口来取代它。 相同对于HashTable，官方推荐ConcurrentHashMap来取代。接着以下的Vector是List以下的一个实现类。 接着最上面的粉红色部分是集合类全部接口关系图。当中Map的结构比较简单，而Collection的结构就相对复杂一些。Collection有三个继承接口：List、Queue和Set。 接下来的绿色部分则是集合类的主要实现类了。这也是我们最常常使用的集合类了。 分类依照实现接口分类：实现Map接口的有：EnumMap、IdentityHashMap、HashMap、LinkedHashMap、WeakHashMap、TreeMap 实现List接口的有：ArrayList、LinkedList 实现Set接口的有：HashSet、LinkedHashSet、TreeSet 实现Queue接口的有：PriorityQueue、LinkedList、ArrayQueue 依据底层实现的数据结构分类：底层以数组的形式实现：EnumMap、ArrayList、ArrayQueue底层以链表的形式实现：LinkedHashSet、LinkedList、LinkedHashMap底层以hash table的形式实现：HashMap、HashSet、LinkedHashMap、LinkedHashSet、WeakHashMap、IdentityHashMap底层以红黑树的形式实现：TreeMap、TreeSet底层以二叉堆的形式实现：PriorityQueue 最下方的一个整块都是java.util.concurrent包里面的类，依照包名我们就能够知道这个包里面的类都是用来处理Java编程中各种并发场景的。 常用集合类特性图片放大效果不佳，建议不要放大看。 工具推荐阅读源代码神器：http://grepcode.com/这个源代码阅读网站不但包括了绝大部分的Java类库源代码，并且对源代码中间的凝视、跳转等做了非常好的优化。有了它，保证你的源代码阅读效率大大提升。 Java 集合系列——博文Java 集合系列01之 总体框架Java 集合系列02之 Collection架构Java 集合系列03之 ArrayList详细介绍(源码解析)和使用示例Java 集合系列04之 fail-fast总结(通过ArrayList来说明fail-fast的原理、解决办法)Java 集合系列05之 LinkedList详细介绍(源码解析)和使用示例Java 集合系列06之 Vector详细介绍(源码解析)和使用示例Java 集合系列07之 Stack详细介绍(源码解析)和使用示例Java 集合系列08之 List总结(LinkedList, ArrayList等使用场景和性能分析)Java 集合系列09之 Map架构Java 集合系列10之 HashMap详细介绍(源码解析)和使用示例Java 集合系列11之 Hashtable详细介绍(源码解析)和使用示例Java 集合系列12之 TreeMap详细介绍(源码解析)和使用示例Java 集合系列13之 WeakHashMap详细介绍(源码解析)和使用示例Java 集合系列14之 Map总结(HashMap, Hashtable, TreeMap, WeakHashMap等使用场景)Java 集合系列15之 Set架构Java 集合系列16之 HashSet详细介绍(源码解析)和使用示例Java 集合系列17之 TreeSet详细介绍(源码解析)和使用示例Java 集合系列18之 Iterator和Enumeration比较 参考文档一张图让你看清Java集合类（Java集合类的总结）","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"},{"name":"集合框架","slug":"集合框架","permalink":"http://yoursite.com/tags/集合框架/"}]},{"title":"JVM调优中CPU调优利器之jstack","slug":"20170822-JVM调优中CPU调优利器之jstack","date":"2017-08-22T09:47:42.000Z","updated":"2018-08-02T03:55:14.826Z","comments":true,"path":"2017/08/22/20170822-JVM调优中CPU调优利器之jstack/","link":"","permalink":"http://yoursite.com/2017/08/22/20170822-JVM调优中CPU调优利器之jstack/","excerpt":"背景：线上服务器CPU飙高，如何找到相关应用，如何定位问题代码。 介绍jstack利器jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。","text":"背景：线上服务器CPU飙高，如何找到相关应用，如何定位问题代码。 介绍jstack利器jstack可以定位到线程堆栈，根据堆栈信息我们可以定位到具体代码，所以它在JVM性能调优中使用得非常多。下面我们来一个实例找出某个Java进程中最耗费CPU的Java线程并定位堆栈信息，用到的命令有ps、top、printf、jstack、grep。 步骤一、找到最耗CPU的进程工具工具top 方法 执行top -c，显示进程运行信息列表 图示如上图，最耗CPU的进程PID为4384 步骤二、找到最耗CPU的线程工具工具top 方法top -Hp xxx，显示一个进程的线程运行信息列表（xxx是上面查出来的进程PID） 图示如上图，进程4384内，最耗CPU的线程PID为4385 步骤三、线程PID转为16进制工具工具：printf 或者 程序计算器 方法方法：printf “%x\\n” 4385 图示注：为啥转为16进制。因为堆栈里，线程id是用16进制表示的。 步骤四、查看堆栈，找到最耗CPU的线程在干嘛工具pstack/jstack/grep 方法jstack 4384 | grep 1211打印进程堆栈通过线程id，过滤得到线程堆栈 图示如上图，找到了耗CPU高的线程对应的线程名称“main”，以及看到了该线程正在执行代码的堆栈。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"jstack","slug":"jstack","permalink":"http://yoursite.com/tags/jstack/"},{"name":"JVM调优","slug":"JVM调优","permalink":"http://yoursite.com/tags/JVM调优/"},{"name":"Java","slug":"Java","permalink":"http://yoursite.com/tags/Java/"}]},{"title":"Spring使用基于Java的配置","slug":"20170819-Spring使用基于Java的配置","date":"2017-08-19T12:54:33.000Z","updated":"2018-08-02T03:55:06.760Z","comments":true,"path":"2017/08/19/20170819-Spring使用基于Java的配置/","link":"","permalink":"http://yoursite.com/2017/08/19/20170819-Spring使用基于Java的配置/","excerpt":"创建基于Java的配置&lt;context:component-scan base-package=”com.springaction.springidol” /&gt;会自己加载使用@Configuration注解标注的类。 定义一个配置类在基于Java的配置里使用@Configuration注解的Java类等价于XML配置中元素。 1234@Configurationpublic class SpringidolConfig &#123; &#125; @Configuration注解会作为一个标示告知Spring:这个类将包含一个或者多个Spring Bean的定义。这些Bean的定义是使用@Bean注解所标注的方法。","text":"创建基于Java的配置&lt;context:component-scan base-package=”com.springaction.springidol” /&gt;会自己加载使用@Configuration注解标注的类。 定义一个配置类在基于Java的配置里使用@Configuration注解的Java类等价于XML配置中元素。 1234@Configurationpublic class SpringidolConfig &#123; &#125; @Configuration注解会作为一个标示告知Spring:这个类将包含一个或者多个Spring Bean的定义。这些Bean的定义是使用@Bean注解所标注的方法。 ## 声明一个简单的Bean1234@Beanpublic User user() &#123; return new User();&#125; 该方法名将作为Bean的ID。使用Java配置相对于XML配置的一个优点：在XML配置中，Bean的类型和ID都是由Spring属性来标示的。Spring表示符的缺点是它们无法在编译器检查。如果重新命名了User类或许会忘记 修改相对应的XML属性。上面的配置文件中使用了Java配置类的三个常用Annotation。@Configuration:用于修饰一个Java配置类。@Bean:用于修饰一个方法，将该方法的返回值定义成容器中的一个Bean。@Value:用于修饰一个Field，用于为该Bean配置一个值，相当于配置一个常量。除了上面的的注解外，在使用Java的配置类时候还有几个常用的Annocation。– @Import:修饰一个Java配置类，用于向当前Java配置类中导入其他Java配置类– @Scope:用于修饰一个方法，指向该方法对应Bean的作用域– @Lazy:用于修饰一个方法，用于指定该方法对应的Bean是否需要延迟初始化– @DependsOn:用于修饰一个方法，指定在初始化该方法对应Bean之前初始化指定Bean。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"SpringBean","slug":"SpringBean","permalink":"http://yoursite.com/tags/SpringBean/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"Java配置","slug":"Java配置","permalink":"http://yoursite.com/tags/Java配置/"}]},{"title":"Spring-6自动检测Bean","slug":"20170819-Spring-6自动检测Bean","date":"2017-08-19T12:54:09.000Z","updated":"2018-08-02T03:54:56.846Z","comments":true,"path":"2017/08/19/20170819-Spring-6自动检测Bean/","link":"","permalink":"http://yoursite.com/2017/08/19/20170819-Spring-6自动检测Bean/","excerpt":"即使context:annotation-config有助于帮助我们完全消除Spring配置中的和元素，但是我们仍然需要使用元素显示定义Bean。使用还有另外一个技巧：context:component-scan。它可以完成context:annotation-config一样的工作，还允许自动检测Bean和定义Bean。使用自动检测，需要context:component-scan来替代context:annotation-config元素。 1&lt;context:component-scan base-package=&quot;com.websystique.spring&quot; /&gt; context:component-scan元素会扫描指定包及其所有的子包。并查找出能够自动注册为Spring Bean的类。这需要构造型(stereotype)进行注解。","text":"即使context:annotation-config有助于帮助我们完全消除Spring配置中的和元素，但是我们仍然需要使用元素显示定义Bean。使用还有另外一个技巧：context:component-scan。它可以完成context:annotation-config一样的工作，还允许自动检测Bean和定义Bean。使用自动检测，需要context:component-scan来替代context:annotation-config元素。 1&lt;context:component-scan base-package=&quot;com.websystique.spring&quot; /&gt; context:component-scan元素会扫描指定包及其所有的子包。并查找出能够自动注册为Spring Bean的类。这需要构造型(stereotype)进行注解。 为自动检测标注Bean特殊注解如下： @Component-通用的构造型注解，标识该类为spring的组件 @Controller-标识将该类定义为 Spring MVC controller @Repository-标识将该类定义为数据仓库 @Service-标示将该类定义为服务 Bean的ID默认为无限定类名。例如：Guitar Bean的ID为guitar。 过滤组件扫描通过为context:component-scan配置context:include-filter或者context:exclude-filter子元素，我们可以随意调整扫描策略。 如果试用了第三方的Instrument的子类实现，或许我们都没有源码的访问权限来添加注解，这时候就可以使用过滤器来解决。context:include-filter告知哪些类需要注册为Spring Beancontext:exclude-filter告知哪些类不需要注册为Spring Bean","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"自动检测Bean","slug":"自动检测Bean","permalink":"http://yoursite.com/tags/自动检测Bean/"}]},{"title":"Spring-5Bean的自动装配","slug":"20170819-Spring-5Bean的自动装配","date":"2017-08-19T12:53:52.000Z","updated":"2018-08-02T03:54:49.302Z","comments":true,"path":"2017/08/19/20170819-Spring-5Bean的自动装配/","link":"","permalink":"http://yoursite.com/2017/08/19/20170819-Spring-5Bean的自动装配/","excerpt":"我们已经知道如何使用元素定义Bean以及使用和元素装配Bean,但是随着应用的不断增加，很遗憾，我们需要编写越来越复杂的XML配置。幸运的是，Spring提供了几种技巧，可以帮助我们减少XML的配置数量。 自动装配 （autowiring）有助于减少甚至消除元素和元素，让Spring自动识别如何装配Bean的依赖关系。 自动检测 （autodiscovery）比自动装配更进了一步，让Spring能否自动识别哪些类需要被配置成Spring Bean，从而减少对元素的使用当自动装配和自动检测在一起使用时，它们可以显著减少Spring的XML配置数量，通常只需要配置少量的几行XML代码，而无需知道在Spring的应用上下文中究竟有多少Bean。","text":"我们已经知道如何使用元素定义Bean以及使用和元素装配Bean,但是随着应用的不断增加，很遗憾，我们需要编写越来越复杂的XML配置。幸运的是，Spring提供了几种技巧，可以帮助我们减少XML的配置数量。 自动装配 （autowiring）有助于减少甚至消除元素和元素，让Spring自动识别如何装配Bean的依赖关系。 自动检测 （autodiscovery）比自动装配更进了一步，让Spring能否自动识别哪些类需要被配置成Spring Bean，从而减少对元素的使用当自动装配和自动检测在一起使用时，它们可以显著减少Spring的XML配置数量，通常只需要配置少量的几行XML代码，而无需知道在Spring的应用上下文中究竟有多少Bean。 自动装配Bean属性自动装配分为4种： byName——寻找和属性名（或者ID）相同的bean自动装配到Bean的对应属性汇总。若找不到，则不进行装配。 byType——寻找和属性类型相同的bean,找不到,装不上,找到多个抛异常。 constructor——把与Bean的构造器入参具有相同类型的其他Bean自动装配到Bean构造器的对应入参中。 autodetect——首先尝试使用constructor进行自动装配。如果失败，再尝试进行byType进行自动装配每一种装配都有自己的优缺点。 byName自动装配举个例子说明： 1234&lt;bean id=&quot;kenny2&quot; class=&quot;com.springaction.springidol.Instrumentalist&quot;&gt; &lt;property name=&quot;song&quot; value=&quot;Jingle Bells&quot; /&gt; &lt;property name=&quot;instrument&quot; ref=&quot;saxophone&quot;/&gt;&lt;/bean&gt; 配置文件中显式配置了Kenny的instrument属性。我们现在修改id为saxophone的bean，修改后：1&lt;bean id=&quot;instrument&quot; class=&quot;com.springaction.springidol.Saxophone&quot;/&gt; 修改之后Saxophone的Bean的id属性与Kenny Bean的instrument的属性的名字是一样的，这时就可以配置autowire属性，实现自动装配。 123&lt;bean id=&quot;kenny2&quot; class=&quot;com.springaction.springidol.Instrumentalist&quot; autowire=&quot;byName&quot;&gt; &lt;property name=&quot;song&quot; value=&quot;Jingle Bells&quot; /&gt;&lt;/bean&gt; byName自动装配遵循一项约定:为属性自动装配ID与该属性的名字相同的Bean。通过设置autowire属性为byName，Spring将特殊对待kenny的所有属性，为这些属性寻找与该名字相同的Spring Bean。 byType自动装配工作方式类似于byName，只不过不在匹配属性的名字而是检查属性的类型。局限性：应用只允许存在一个Bean与需要装配的属性类型相匹配。可能会存在多个类型相同的Bean，为了避免因为使用byType带来歧义，我们有两个选择： 可以为自动装配标示一个首选Bean 可以取消某个Bean自动装配的候选资格。首选Bean，可以使用的primary属性。如果一个bean属性的primary属性值设置为true，那么该bean将比其他bean优先被选择。但是很诡异的一点是：设置为true之后，所有的Bean都将变成首选Bean，也就不存在首选Bean了。所以，如果使用primary属性，就需要将所有非首选Bean的primary属性设置为false。 constructor自动装配使用constructor注入来装配Bean，我们可以移除元素，又Spring在应用上下文中自动选择Bean注入到构造器入参中。constructor自动装配和byType自动装配都具有相同的局限性，如果一个类有多个构造器，他们都满足自动装配条件时，Spring是不会猜测哪一个构造器更适合使用。 最佳自动装配首先尝试constructor自动装配，如果没有发现与构造器相匹配的Bean时，Spring将尝试使用byType自动装配。 默认自动匹配在根元素上增加一个default-autowire属性，则可以为Spring应用上下文中的每一个Bean配置相同的autowire属性。 使用注解自动装配使用注解方式允许更细粒度的自动装配。spring容器默认禁用注解装配。启用方式：使用Spring的context命名空间配置中的&lt;context:annotation-config /&gt;元素。Spring支持几种不同的用于自动装配的注解。 Spring自带的@Autowired注解 JSR-330的@Inject注解 JSR-250的@Resource注解 使用Autowired使用@Autowired注解时候，Spring将会尝试对该方法执行byType自动装配@Autowired注解可以标注setter方法、自动装配Bean应用的任意方法、注解标注属性(就可以删除setter方法了)。当对构造器进行标注时候，即使在spring XML中没有使用元素配置Bean，该构造器也需要进行自动装配（使用构造器装配）。两种阻碍场景：没有匹配到Bean、存在多个匹配的Bean。 解决阻碍，我们可以使用可选的自动装配 可选的自动装配@Autowired注解具有很强的契约型特征，其标注的属性或参数必须是可装配的。属性并不一定非要装配，null值也可以接受的场景下，我们通过设置@Autowired的required属性为false来配置自动装配是可选的。12@Autowired(require=false)private Instrument instrument; 当使用@Autowired标注多个构造器时，Spring就会从所有满足装配条件的构造器中选择入参最多的那个构造器。 限定歧义性依赖假设我们有两个Bean都实现了Instrument接口，这种场景下@Autowired注解没有办法选择哪一个Bean才是真正需要的。这样会抛出异常：NoSuchBeanDefinitionException异常，装配失败。但是我们可以使用@Qualifier注解来明确指定需要装配的bean。123@Autowired@Qualifier(&quot;guitar&quot;)private Instrument instrument; 使用@Qualifier意味着把@Autowired的byType自动转换为byName。 创建自动一的限定器(Qualifier)本文不做讲解，可自行查阅《Spring 实战》 借助@Inject实现基于标准的自动装配@Inject属于Java依赖注入规范，与@Autowired的不同是：@Inject没有required属性。本文不做讲解，可自行查阅《Spring 实战》","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"自动装配","slug":"自动装配","permalink":"http://yoursite.com/tags/自动装配/"}]},{"title":"Spring-4使用表达式装配","slug":"20170819-Spring-4使用表达式装配","date":"2017-08-19T12:53:33.000Z","updated":"2018-08-02T03:54:38.760Z","comments":true,"path":"2017/08/19/20170819-Spring-4使用表达式装配/","link":"","permalink":"http://yoursite.com/2017/08/19/20170819-Spring-4使用表达式装配/","excerpt":"到目前为止我们为Bean的属性和构造器参数装配的所有东西都是在Sping的xml文件中静态定义的。但是如果我们为属性装配的值只又在运行的时期才能知道，如何实现？","text":"到目前为止我们为Bean的属性和构造器参数装配的所有东西都是在Sping的xml文件中静态定义的。但是如果我们为属性装配的值只又在运行的时期才能知道，如何实现？参考：Spring实战-使用表达式装配（三）","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Spel","slug":"Spel","permalink":"http://yoursite.com/tags/Spel/"},{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"}]},{"title":"Spring-3注入Bean属性","slug":"20170819-Spring-3注入Bean属性","date":"2017-08-19T12:51:02.000Z","updated":"2017-08-19T13:17:55.805Z","comments":true,"path":"2017/08/19/20170819-Spring-3注入Bean属性/","link":"","permalink":"http://yoursite.com/2017/08/19/20170819-Spring-3注入Bean属性/","excerpt":"Spring使用一种被称为是“依赖注入”的方式管理Bean之间的依赖关系。依赖注入是一种优秀的解耦方式。Spring的依赖注入（Dependency Injection, DI）还有一个的名字：“控制反转”(Inversion of Control，IOC)。DI与IOC的含义完全相同。 注入Bean属性依赖注入分为两种：构造器注入（通过构造参数来注入值）、设置注入（通过调用属性的setter方法来注入值）。","text":"Spring使用一种被称为是“依赖注入”的方式管理Bean之间的依赖关系。依赖注入是一种优秀的解耦方式。Spring的依赖注入（Dependency Injection, DI）还有一个的名字：“控制反转”(Inversion of Control，IOC)。DI与IOC的含义完全相同。 注入Bean属性依赖注入分为两种：构造器注入（通过构造参数来注入值）、设置注入（通过调用属性的setter方法来注入值）。通常，JavaBean的属性是私有的，同时会提供一组存取器方法，以setXX()和getXXX()形式存在，spring的设置注入就是借助属性的set方法来配置属性的值。 注入简单值123&lt;bean id=&quot;kenny&quot; class=&quot;com.springinaction.springidol.Instrumentalist&quot;&gt; &lt;property name=&quot;song&quot; value=&quot;Jingle Bells&quot; /&gt;&lt;/bean&gt; 在Spring中我们使用元素配置Bean属性。跟类似，区别在于，前者是setter方法注入值，后者是通过构造参数注入值。 引用其他Bean1234&lt;bean id=&quot;kenny&quot; class=&quot;com.springinaction.springidol.Instrumentalist&quot;&gt; &lt;property name=&quot;song&quot; value=&quot;Jingle Bells&quot; /&gt; &lt;property name=&quot;instrument&quot; ref=&quot;saxophone&quot; /&gt;&lt;/bean&gt; ==Spring只要看到子元素，Spring框架就会在底层以反射方式执行一次setter方法。==Spring底层会执行形如一下格式的代码：1234567String nameStr = ...;String refStr = ...;String setterName = &quot;set&quot; + nameStr.substring(0, 1).toUpperCase() + nameStr.substring(1);// 生成将要调用的setter方法名Object paramBean = container.get(setterName);Method setter = class.getMethod(setterName, paramBean.getClass());// 此处的Obj参数是前一段反射代码为&lt;bean .../&gt;元素创建的对象setter.invoke(obj, paramBeam); Spring底层代码会更完善一些。 注入内部Bean内部bean是定义在其他bean内部的bean，如下配置将萨克斯声明为内部bean： 123456&lt;bean id=&quot;kenny&quot; class=&quot;com.springinaction.springidol.Instrumentalist&quot;&gt; &lt;property name=&quot;song&quot; value=&quot;Jingle Bells&quot; /&gt; &lt;property name=&quot;instrument&quot;&gt; &lt;bean class=&quot;com.springinaction.springidol.Saxophone&quot; /&gt; &lt;/property&gt;&lt;/bean&gt; 内部bean并不仅限于setter注入，我们还可以把内部bean装配到构造方法的入参中，正如下面的duke的新声明所展示的： 123456&lt;bean id=&quot;duke&quot; class=&quot;com.springinaction.springidol.PoeticJuggler&quot;&gt; &lt;constructor-arg value=&quot;25&quot; /&gt; &lt;constructor-arg&gt; &lt;bean class=&quot;com.springinaction.springidol.Sonnet29&quot; /&gt; &lt;/constructor-arg&gt;&lt;/bean&gt; 内部bean没有ID属性，虽然为内部bean配置一个ID属性完全是合法的，但是却没有必要。内部类最大的缺点：不能被复用。内部bean仅适用于一次注入，而且也不能被其他bean应用。使用内部bean会影响Spring XML配置的可读性。 装配集合value和ref仅在Bean的属性值是单个值的情况下才有用。当Bean的属性类型是集合时，又该如何配置呢？String提供了4种类型的集合的装配元素： 集合元素 用途 装配list类型的值，允许重复 装配set类型的值，不允许重复 装配map类型的值，名称和值可以是任意类型 装配properties类型的值，名称和值必须是String类型 当属性为任意的Java.util.Collection类型时，和几乎可以完全互换。 和这两个元素分别对应java.util.Map和java.util.Properties。当我们需要由键-值对组成的集合时，这两种配置元素非常有用。 装配List、Set、ArrayHank能够同时演奏多种乐器，由类OneManBand定义：12345678910111213141516171819package com.springinaction.springidol;import java.util.Collection;public class OneManBand implements Performer &#123; public OneManBand() &#123;&#125; public void perform() throws PerformanceException &#123; for (Instrument instrument : instruments) &#123; instrument.play(); &#125; &#125; private Collection&lt;Instrument&gt; instruments; // 集合 public void setInstruments(Collection&lt;Instrument&gt; instruments) &#123; this.instruments = instruments; &#125;&#125; 我们使用list配置元素为Hank赋予表演时所用到的乐器集合：123456789&lt;bean id=&quot;hank&quot; class=&quot;com.springinaction.springidol.OneManBand&quot;&gt; &lt;property name=&quot;instruments&quot;&gt; &lt;list&gt; &lt;ref bean=&quot;guitar&quot; /&gt; &lt;ref bean=&quot;cymbal&quot; /&gt; &lt;ref bean=&quot;harmonica&quot; /&gt; &lt;/list&gt; &lt;/property&gt;&lt;/bean&gt; list元素包含一个或多个值，这里的ref元素用来定义在spring上下文中的其他bean引用。当然还可以使用其他的spring设置元素作为list的成员，包括、和。实际上，list可以包含另一个list作为其成员，形成多维列表。 装配Map集合当OneManBand表演时，假设我们还想知道每一个音符是由哪种乐器产生的，OneManBand可以调整如下：12345678910111213141516171819202122package com.springinaction.springidol;import java.util.Collection;import java.util.Map;public class OneManBand implements Performer &#123; public OneManBand() &#123;&#125; public void perform() throws PerformanceException &#123; for (String key : instruments.keySet()) &#123; System.out.println(key + &quot;:&quot;); Instrument instrument = instruments.get(key); instrument.play(); &#125; &#125; private Map&lt;String, Instrument&gt; instruments; public void setInstruments(Map&lt;String, Instrument&gt; instruments) &#123; this.instruments = instruments; &#125;&#125; 使用map元素配置instruments属性，如下所示： 123456789&lt;bean id=&quot;hank&quot; class=&quot;com.springinaction.springidol.OneManBand&quot;&gt; &lt;property name=&quot;instruments&quot;&gt; &lt;map&gt; &lt;entry key=&quot;GUITAR&quot; value-ref=&quot;guitar&quot; /&gt; &lt;entry key=&quot;CYMBAL&quot; value-ref=&quot;cymbal&quot; /&gt; &lt;entry key=&quot;HARMONICA&quot; value-ref=&quot;harmonica&quot; /&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; map中的entry元素由一个键和一个值组成，键和值可以是简单类型，也可以是其他类型的引用，这些属性将帮助我们指定entry的键和值： 属性 用途 key 指定map中entry的键为String key-ref 指定map中entry的键为spring上下文中其他bean的引用 value 指定map中entry的值为String value-ref 指定map中entry的值为spring上下文中其他bean的引用 装配Properties集合123456789&lt;bean id=&quot;hank&quot; class=&quot;com.springinaction.springidol.XXX&quot;&gt;&lt;property name=&quot;instruments&quot;&gt; &lt;props&gt; &lt;prop key=&quot;GUITAR&quot;&gt;STRUM STRUM STRUM&lt;/prop&gt; &lt;prop key=&quot;CYMBAL&quot;&gt;CRASH CRASH CRASH&lt;/prop&gt; &lt;prop key=&quot;HARMONICA&quot;&gt;HUM HUM HUM&lt;/prop&gt; &lt;/props&gt;&lt;/property&gt;&lt;/bean&gt; 说明： 元素用于把值或bean引用注入到bean的属性中 元素用于定义一个java.util.Properties类型的集合值 元素用于定义集合的一个成员。装配空值通常情况下bean属性的最初值都是null，直到你为它赋值，但是有些bean会为它的属性默认设置一个非空值。如果因为某些特殊原因，必须把属性设置为空值，则可以显式地为该属性装配一个null值。为属性设置null值，只需使用元素，例如：1&lt;property name=&quot;someNonNullProperty&quot;&gt;&lt;null/&gt;&lt;/property&gt; 显式地为属性装配null值的另一个理由是覆盖自动装配的值。 使用命名空间p装配属性跟命名空间p是等价的，命名空间p的最主要优点是更简洁。命名空间p的schema URI为http://www.springframework.org/schema/p。如果你想使用命名空间p，主需要在spring的XML配置中增加如下一段声明：12345&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt; 使用范例如下： 123&lt;bean id=&quot;kenny2&quot; class=&quot;com.springinaction.springidol.Instrumentalist&quot; p:song=&quot;Jingle Bells&quot; p:instrument-ref=&quot;saxophone&quot; /&gt; -ref后缀作为一个标识来告知spring应该装配一个引用而不是字面值。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://yoursite.com/tags/Spring/"},{"name":"依赖注入","slug":"依赖注入","permalink":"http://yoursite.com/tags/依赖注入/"}]},{"title":"Spring声明Bean","slug":"20170819-Spring-2声明Bean","date":"2017-08-19T10:27:34.000Z","updated":"2017-08-19T13:18:43.910Z","comments":true,"path":"2017/08/19/20170819-Spring-2声明Bean/","link":"","permalink":"http://yoursite.com/2017/08/19/20170819-Spring-2声明Bean/","excerpt":"创建应用对象之间协作关系的行为通常被称为装配，这也是Spring依赖注入的本质。 Spring容器Spring有两个很接口：BeanFactory和ApplicationContext接口，它们都可代表Spring容器，Spring容器是生成Bean实例的工厂，并管理容器中的Bean。 声明Bean创建Spring配置Spring是一个基于容器的框架，如果没有配置Spring，那它就是一个空容器，对于我们也就毫无用处。因此，我们需要配置Spring来告诉容器需要加载哪些Bean和如何装配这些Bean。 Spring容器提供了两种装配Bean的方式： 使用一个或多个XML文件作为配置文件 基于Java注解进行配置","text":"创建应用对象之间协作关系的行为通常被称为装配，这也是Spring依赖注入的本质。 Spring容器Spring有两个很接口：BeanFactory和ApplicationContext接口，它们都可代表Spring容器，Spring容器是生成Bean实例的工厂，并管理容器中的Bean。 声明Bean创建Spring配置Spring是一个基于容器的框架，如果没有配置Spring，那它就是一个空容器，对于我们也就毫无用处。因此，我们需要配置Spring来告诉容器需要加载哪些Bean和如何装配这些Bean。 Spring容器提供了两种装配Bean的方式： 使用一个或多个XML文件作为配置文件 基于Java注解进行配置 使用XML文件声明bean时，Spring配置文件的根元素来源于spring beans命令空间所定义的元素。在元素内，可以放置所有的Spring配置元素。下面是一个典型的Spring XML配置文件： 1234567&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;&lt;/beans&gt; 但是不是唯一的Soring命名空间，Spring的核心框架自带了10个明明空间配置。 命名空间 用途 aop 为声明切面以及将@AspectJ注解的类代理为Spring切面提供了配置元素 beans 支持声明bean和装配bean，是Spring最核心也是最原始的命名空间 context 为配置Spring上下文提供了配置元素，包括自动检测和自动装配Bean、注入非Spring直接管理的对象 jee 提供了与Java EE API的集成，例如JNDI、EJB jms 为声明消息驱动的POJO提供了配置元素 lang 支持配置由Groovy、JRuby或BeanShell等脚本实现的Bean mvc 启用Spring MVC的能力 oxm 支持Spring对象到XML映射配置 tx 提供声明式事务配置 util 提供各种各样的工具类元素，包括把集合配置为Bean、支持属性占位符元素 除了Spring框架自带的命名空间，Spring Portfolio的许多成员也提供了它们自己的Spring命名空间配置。 声明一个简单的Bean声明一个杂技师类Juggler，代码如下：12345678910111213141516171819package com.springinaction.springidol;public class Juggler implements Performer &#123; private int beanBags = 3; public Juggler() &#123; &#125; public Juggler(int beanBags) &#123; this.beanBags = beanBags; &#125; public void perform() throws PerformanceException &#123; System.out.println(&quot;JUGGLING &quot; + beanBags + &quot; BEANBAGS&quot;); &#125;&#125;Juggler类默认可以同时抛3个豆袋子，但是也可以通过构造器设置豆袋子的个数。 声明一个bean：1&lt;bean id=&quot;duke&quot; class=&quot;com.springinaction.springidol.Juggler&quot; /&gt; 元素是Spring中最基本的配置单元。当Spring容器加载该bean时，Spring默认使用构造器类实例化duke Bean。深层次来说，配置文件中的 默认以反射方式来调用该类无参数的构造器。Spring框架解析上面的元素可以得到两个字符串：其中idStr=”duke”,classStr=”com.springinaction.springidol.Juggler”。Spring底层会执行形如一下格式的代码：123456String idStr = ...;String classStr = ...;Class clazz = Class.forName(classStr);Object obj = clazz.newInstance();container.put(idStr, obj);// container代表Spring容器 上面是最基本的反射代码，在Spring底层中，代码会更完善一些。 实际上，duke会使用如下代码来创建： 1new com.springinaction.springidol.Juggler(); 为了给duke一个排练机会，可以使用如下代码加载spring上下文： 1234ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;spring-idol.xml&quot;);Performer performer = (Performer)ctx.getBean(&quot;duke&quot;);performer.perform(); 为了能让评委心动，duke决定打破世界纪录：同时抛15个豆袋子。下面我们使用带参数的构造方法来设置个数。 构造器注入123&lt;bean id=&quot;duke&quot; class=&quot;com.springinaction.springidol.Juggler&quot;&gt; &lt;constructor-arg value=&quot;15&quot; /&gt;&lt;/bean&gt; 在构造Bean的时候，我们使用元素告诉Spring额外的信息。 注入对象引用我们不能使用的ref属性为第二个构造函数赋值，因为我们将要出入的是对象。这里我们使用ref属性来指向要注入bean的id。此时Spring将会执行如下的代码： 123456Stirng idStr = ...;String refStr = ...;Object paramBean = constainer.get(refStr);Object obj = new xxx(paramBean);// xxx为bean的包名+类名// constainer代表Spring容器constainer.put(idStr, obj); 通过工厂方法创建Bean有时候静态工厂方法是实例化对象的唯一方法，spring支持通过元素的factory-method属性来装配工厂创建的bean。一般来说，单例类的实例只能通过静态工厂方法来创建。Stage类是一个典型的单例类： 12345678910111213package com.springinaction.springidol;public class Stage &#123; private Stage() &#123;&#125; private static class StageSingletonHolder&#123; static Stage instance = new Stage(); &#125; public static Stage getInstance() &#123; return StageSingletonHolder.instance; &#125;&#125; 为了在spring上下文中将Stage配置为bean，可以像下面的配置来使用factory-method： 12&lt;bean id=&quot;theStage&quot; class=&quot;com.springinaction.springidol.Stage&quot; factory-method=&quot;getInstance&quot; /&gt; Bean的作用域Spring的bean作用域允许用户配置所创建的Bean属于哪一种作用域，而无需在Bean的实现里硬编码作用域规则。 作用域 定义 singleton 在每一个spring容器中，一个bean定义只有一个对象实例（默认） prototype 允许bean的定义被实例化任意次（每次调用豆创建一个实例） request 在一次HTTP请求中，每个bean定义对应一个实例。该作用域仅在基于web的spring上下文（例如spring mvc）中才有效 session 在一个HTTP Session中，每个bean对应一个实例。该作用域仅在基于web的spring上下文（例如spring mvc）中才有效 global-session 在一个全局HTTP Session中，每个bean定义一个实例。该作用域仅在Protlet上下文中才有效。 注意：spring有关单例的概念限于spring上下文的范围内，不像真正的单例，在每个类加载器中保证只有一个实例。spring的单例只能保证在每个应用上下文中只有一个bean的实例。没有人能够阻止你使用传统的方式实话同一个bean，甚至你可以定义几个声明来实例化同一个Bean。 初始化和销毁Bean为满足初始化和销毁Bean的需求，Spring提供了Bean的声明周期的钩子方法。为bean定义初始化和销毁操作，只需要使用init-method和destroy-method参数来配置bean元素，init-method属性指定了在初始化bean时要调用的方法，类似的，destroy-method属性指定了bean从容器移除之前要调用的方法。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"SpringBean","slug":"SpringBean","permalink":"http://yoursite.com/tags/SpringBean/"}]},{"title":"SpringBean的生命周期","slug":"20170818-SpringBean的生命周期","date":"2017-08-18T10:27:34.000Z","updated":"2018-08-02T03:53:40.227Z","comments":true,"path":"2017/08/18/20170818-SpringBean的生命周期/","link":"","permalink":"http://yoursite.com/2017/08/18/20170818-SpringBean的生命周期/","excerpt":"传统JavaBean的生命周期在传统的Java应用中，，bean的生命周期很简单。使用字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。","text":"传统JavaBean的生命周期在传统的Java应用中，，bean的生命周期很简单。使用字new进行bean实例化，然后该bean就可以使用了。一旦该bean不再被使用，则由Java自动进行垃圾回收。 Spring容器中Bean的生命周期正确理解Spring bean的生命周期非常重要，因为你或许要利用Spring提供的扩展点来自定义bean的创建过程。 下面是bean装载到Spring应用上下文中的一个典型的生命周期过程，在bean准备就绪之前，bean工厂执行了若干启动步骤。 bean在Spring容器中从创建到销毁经历了若干阶段，每一阶段都可以针对Spring如何管理bean进行个性化定制。 详细描述 Spring对bean进行实例化； Spring将值和bean的引用注入到bean对应的属性中； 如果bean实现了BeanNameAware接口，Spring将bean的ID传递给setBean-Name()方法； 如果bean实现了BeanFactoryAware接口，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入； 如果bean实现了ApplicationContextAware接口，Spring将调用setApplicationContext()方法，将bean所在的应用上下文的引用传入进来； 如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessBeforeInitialization()方法； 如果bean实现了InitializingBean接口，Spring将调用它们的afterPropertiesSet()方法。类似地，如果bean使用init-method声明了初始化方法，该方法也会被调用； 如果bean实现了BeanPostProcessor接口，Spring将调用它们的postProcessAfterInitialization()方法； 此时，bean已经准备就绪，可以被应用程序使用了，它们将一直驻留在应用上下文中，直到该应用上下文被销毁； 如果bean实现了DisposableBean接口，Spring将调用它的destroy()接口方法。同样，如果bean使用destroy-method声明了销毁方法，该方法也会被调用。","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"Spring Bean","slug":"Spring-Bean","permalink":"http://yoursite.com/tags/Spring-Bean/"}]},{"title":"Spring AOP介绍及源码分析(转)","slug":"20170816-SpringAOP介绍及源码分析","date":"2017-08-17T11:39:37.000Z","updated":"2018-08-02T03:53:17.654Z","comments":true,"path":"2017/08/17/20170816-SpringAOP介绍及源码分析/","link":"","permalink":"http://yoursite.com/2017/08/17/20170816-SpringAOP介绍及源码分析/","excerpt":"导言软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充。","text":"导言软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模软件开发经历了从汇编语言到高级语言和从过程化编程到面向对象编程；前者是为了提高开发效率，而后者则使用了归纳法，把具有共性的东西进行归类并使之模块化，达到便于维护和扩展的目的；如果说面向对象编程可以对业务需求进行很好的分解使之模块化；那么面向切面编程AOP（Aspect-Oriented Programming）则可以对系统需求进行很好的模块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充；块组织，简化系统需求和实现之间的对比关系，是对OOP思想的一种补充。 源文链接Spring AOP介绍及源码分析","categories":[{"name":"技术","slug":"技术","permalink":"http://yoursite.com/categories/技术/"}],"tags":[{"name":"SpringAop","slug":"SpringAop","permalink":"http://yoursite.com/tags/SpringAop/"}]},{"title":"IntelliJIdea常用快捷键列表","slug":"20170818-IntelliJIdea常用快捷键列表","date":"2017-04-18T06:28:25.000Z","updated":"2018-08-02T03:53:35.285Z","comments":true,"path":"2017/04/18/20170818-IntelliJIdea常用快捷键列表/","link":"","permalink":"http://yoursite.com/2017/04/18/20170818-IntelliJIdea常用快捷键列表/","excerpt":"常用Ctrl+Shift + Enter，语句完成“！”，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件","text":"常用Ctrl+Shift + Enter，语句完成“！”，否定完成，输入表达式时按 “！”键Ctrl+E，最近的文件Ctrl+Shift+E，最近更改的文件Shift+Click，可以关闭文件Ctrl+[ OR ]，可以跑到大括号的开头与结尾Ctrl+F12，可以显示当前文件的结构Ctrl+F7，可以查询当前元素在当前文件中的引用，然后按 F3 可以选择Ctrl+N，可以快速打开类Ctrl+Shift+N，可以快速打开文件Alt+Q，可以看到当前方法的声明Ctrl+P，可以显示参数信息Ctrl+Shift+Insert，可以选择剪贴板内容并插入Alt+Insert，可以生成构造器/Getter/Setter等Ctrl+Alt+V，可以引入变量。例如：new String(); 自动导入变量定义Ctrl+Alt+T，可以把代码包在一个块内，例如：try/catchCtrl+Enter，导入包，自动修正Ctrl+Alt+L，格式化代码Ctrl+Alt+I，将选中的代码进行自动缩进编排，这个功能在编辑 JSP 文件时也可以工作Ctrl+Alt+O，优化导入的类和包Ctrl+R，替换文本Ctrl+F，查找文本Ctrl+Shift+Space，自动补全代码Ctrl+空格，代码提示（与系统输入法快捷键冲突）Ctrl+Shift+Alt+N，查找类中的方法或变量Alt+Shift+C，最近的更改Alt+Shift+Up/Down，上/下移一行Shift+F6，重构 – 重命名Ctrl+X，删除行Ctrl+D，复制行Ctrl+/或Ctrl+Shift+/，注释（//或者/**/）Ctrl+J，自动代码（例如：serr）Ctrl+Alt+J，用动态模板环绕Ctrl+H，显示类结构图（类的继承层次）Ctrl+Q，显示注释文档Alt+F1，查找代码所在位置Alt+1，快速打开或隐藏工程面板Ctrl+Alt+left/right，返回至上次浏览的位置Alt+left/right，切换代码视图Alt+Up/Down，在方法间快速移动定位Ctrl+Shift+Up/Down，向上/下移动语句F2 或 Shift+F2，高亮错误或警告快速定位Tab，代码标签输入完成后，按 Tab，生成代码Ctrl+Shift+F7，高亮显示所有该文本，按 Esc 高亮消失Alt+F3，逐个往下查找相同文本，并高亮显示Ctrl+Up/Down，光标中转到第一行或最后一行下Ctrl+B/Ctrl+Click，快速打开光标处的类或方法（跳转到定义处）Ctrl+Alt+B，跳转到方法实现处Ctrl+Shift+Backspace，跳转到上次编辑的地方Ctrl+O，重写方法Ctrl+Alt+Space，类名自动完成Ctrl+Alt+Up/Down，快速跳转搜索结果Ctrl+Shift+J，整合两行Alt+F8，计算变量值Ctrl+Shift+V，可以将最近使用的剪贴板内容选择插入到文本Ctrl+Alt+Shift+V，简单粘贴Shift+Esc，不仅可以把焦点移到编辑器上，而且还可以隐藏当前（或最后活动的）工具窗口F12，把焦点从编辑器移到最近使用的工具窗口Shift+F1，要打开编辑器光标字符处使用的类或者方法 Java 文档的浏览器Ctrl+W，可以选择单词继而语句继而行继而函数Ctrl+Shift+W，取消选择光标所在词Alt+F7，查找整个工程中使用地某一个类、方法或者变量的位置Ctrl+I，实现方法Ctrl+Shift+U，大小写转化Ctrl+Y，删除当前行Shift+Enter，向下插入新行psvm/sout，main/System.out.println(); Ctrl+J，查看更多Ctrl+Shift+F，全局查找Ctrl+F，查找/Shift+F3，向上查找/F3，向下查找Ctrl+Shift+S，高级搜索Ctrl+U，转到父类Ctrl+Alt+S，打开设置对话框Alt+Shift+Inert，开启/关闭列选择模式Ctrl+Alt+Shift+S，打开当前项目/模块属性Ctrl+G，定位行Alt+Home，跳转到导航栏Ctrl+Enter，上插一行Ctrl+Backspace，按单词删除Ctrl+”+/-”，当前方法展开、折叠Ctrl+Shift+”+/-”，全部展开、折叠【调试部分、编译】Ctrl+F2，停止Alt+Shift+F9，选择 DebugAlt+Shift+F10，选择 RunCtrl+Shift+F9，编译Ctrl+Shift+F10，运行Ctrl+Shift+F8，查看断点F8，步过F7，步入Shift+F7，智能步入Shift+F8，步出Alt+Shift+F8，强制步过Alt+Shift+F7，强制步入Alt+F9，运行至光标处Ctrl+Alt+F9，强制运行至光标处F9，恢复程序Alt+F10，定位到断点Ctrl+F8，切换行断点Ctrl+F9，生成项目Alt+1，项目Alt+2，收藏Alt+6，TODOAlt+7，结构Ctrl+Shift+C，复制路径Ctrl+Alt+Shift+C，复制引用，必须选择类名Ctrl+Alt+Y，同步Ctrl+~，快速切换方案（界面外观、代码风格、快捷键映射等菜单）Shift+F12，还原默认布局Ctrl+Shift+F12，隐藏/恢复所有窗口Ctrl+F4，关闭Ctrl+Shift+F4，关闭活动选项卡Ctrl+Tab，转到下一个拆分器Ctrl+Shift+Tab，转到上一个拆分器 重构Ctrl+Alt+Shift+T，弹出重构菜单Shift+F6，重命名F6，移动F5，复制Alt+Delete，安全删除Ctrl+Alt+N，内联 查找Ctrl+F，查找Ctrl+R，替换F3，查找下一个Shift+F3，查找上一个Ctrl+Shift+F，在路径中查找Ctrl+Shift+R，在路径中替换Ctrl+Shift+S，搜索结构Ctrl+Shift+M，替换结构Alt+F7，查找用法Ctrl+Alt+F7，显示用法Ctrl+F7，在文件中查找用法Ctrl+Shift+F7，在文件中高亮显示用法","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/工具/"},{"name":"IntelliJ Idea","slug":"IntelliJ-Idea","permalink":"http://yoursite.com/tags/IntelliJ-Idea/"}]},{"title":"利用Github搭建自己的博客","slug":"20170816-使用利用Github搭建自己的博客","date":"2017-03-01T13:17:07.000Z","updated":"2018-08-02T03:53:29.028Z","comments":true,"path":"2017/03/01/20170816-使用利用Github搭建自己的博客/","link":"","permalink":"http://yoursite.com/2017/03/01/20170816-使用利用Github搭建自己的博客/","excerpt":"","text":"工具Github账号、Hexo在利用Github创建个人博客的过程中遇到了很多坑，找了很多的文档最终搭建好。 参考的文档小茗同学的博客园hexo博客图片问题","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/工具/"}],"tags":[{"name":"个人博客","slug":"个人博客","permalink":"http://yoursite.com/tags/个人博客/"},{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]},{"title":"Hello World","slug":"20170725-hello-world","date":"2017-03-01T12:07:37.000Z","updated":"2017-08-19T12:35:03.192Z","comments":true,"path":"2017/03/01/20170725-hello-world/","link":"","permalink":"http://yoursite.com/2017/03/01/20170725-hello-world/","excerpt":"","text":"第一篇博客，记录一下。","categories":[],"tags":[]}]}